<div itemscope itemtype="http://developers.google.com/ReferenceObject">
<meta itemprop="name" content="tff.federated_aggregate" />
<meta itemprop="path" content="Stable" />
</div>

# tff.federated_aggregate

<table class="tfo-notebook-buttons tfo-api" align="left">
</table>

<a target="_blank" href="http://github.com/tensorflow/federated/tree/master/tensorflow_federated/python/core/api/intrinsics.py">View
source</a>

Aggregates `value` from <a href="../tff.md#CLIENTS"><code>tff.CLIENTS</code></a>
to <a href="../tff.md#SERVER"><code>tff.SERVER</code></a>.

```python
tff.federated_aggregate(
    value,
    zero,
    accumulate,
    merge,
    report
)
```

<!-- Placeholder for "Used in" -->

This generalized aggregation function admits multi-layered architectures that
involve one or more intermediate stages to handle scalable aggregation across a
very large number of participants.

The multi-stage aggregation process is defined as follows:

*   Clients are organized into groups. Within each group, a set of all the
    member constituents of `value` contributed by clients in the group are first
    reduced in a manner similar to
    <a href="../tff/federated_reduce.md"><code>tff.federated_reduce</code></a>
    using reduction operator `accumulate` with `zero` as the zero in the
    algebra. As described in the documentation for
    <a href="../tff/federated_reduce.md"><code>tff.federated_reduce</code></a>,
    if members of `value` are of type `T`, and `zero` (the result of reducing an
    empty set) is of type `U`, the reduction operator `accumulate` used at this
    stage should be of type `(<U,T> -> U)`. The result of this stage is a set of
    items of type `U`, one item for each group of clients.

*   Next, the `U`-typed items generated by the preceding stage are merged using
    the binary commutative associative operator `merge` of type `(<U,U> -> U)`.
    This can be interpreted as a
    <a href="../tff/federated_reduce.md"><code>tff.federated_reduce</code></a>
    using `merge` as the reduction operator, and the same `zero` in the algebra.
    The result of this stage is a single top-level `U` that emerges at the root
    of the hierarchy at the
    <a href="../tff.md#SERVER"><code>tff.SERVER</code></a>. Actual
    implementations may structure this step as a cascade of multiple layers.

*   Finally, the `U`-typed result of the reduction performed in the preceding
    stage is projected into the result value using `report` as the mapping
    function (for example, if the structures being merged consist of counters,
    this final step might include computing their ratios).

#### Args:

*   <b>`value`</b>: A value of a TFF federated type placed at
    <a href="../tff.md#CLIENTS"><code>tff.CLIENTS</code></a> to aggregate.
*   <b>`zero`</b>: The zero of type `U` in the algebra of reduction operators,
    as described above.
*   <b>`accumulate`</b>: The reduction operator to use in the first stage of the
    process. If `value` is of type `{T}@CLIENTS`, and `zero` is of type `U`,
    this operator should be of type `(<U,T> -> U)`.
*   <b>`merge`</b>: The reduction operator to employ in the second stage of the
    process. Must be of type `(<U,U> -> U)`, where `U` is as defined above.
*   <b>`report`</b>: The projection operator to use at the final stage of the
    process to compute the final result of aggregation. If the intended result
    to be returned by
    <a href="../tff/federated_aggregate.md"><code>tff.federated_aggregate</code></a>
    is of type `R@SERVER`, this operator must be of type `(U -> R)`.

#### Returns:

A representation on the <a href="../tff.md#SERVER"><code>tff.SERVER</code></a>
of the result of aggregating `value` using the multi-stage process described
above.

#### Raises:

*   <b>`TypeError`</b>: if the arguments are not of the types specified above.
