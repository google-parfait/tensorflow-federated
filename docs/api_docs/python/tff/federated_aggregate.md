<div itemscope itemtype="http://developers.google.com/ReferenceObject">
<meta itemprop="name" content="tff.federated_aggregate" />
<meta itemprop="path" content="Stable" />
</div>

# tff.federated_aggregate

``` python
tff.federated_aggregate(
    value,
    zero,
    accumulate,
    merge,
    report
)
```



Defined in [`core/api/intrinsics.py`](http://github.com/tensorflow/federated/tree/master/tensorflow_federated/python/core/api/intrinsics.py).

Aggregates `value` from `CLIENTS` to `SERVER` using a multi-stage process.

This generalized aggregation function admits multi-layered architectures that
involve one or more intermediate stages to handle scalable aggregation across
a very large number of participants.

The aggregation process is defined as follows:

* Clients are organized into groups. Within each group, a set of all the
  member constituents of `value` contributed by clients in the group are first
  reduced in a manner similar to `federated_reduce` using reduction operator
  `accumulate` with `zero` as the zero in the algebra. As described in the
  documentation for `federated_reduce`, if members of `value` are of type `T`,
  and `zero` (the result of reducing an empty set) is of type `U`, the
  reduction operator `accumulate` used at this stage should be of type
  `(<U,T> -> U)`. The result of this stage is a set of items of type `U`, one
  item for each group of clients.

* Next, the `U`-typed items generated by the preceding stage are merged using
  the binary commutative associative operator `merge` of type `(<U,U> -> U)`.
  This can be interpreted as a `federated_reduce` using `merge` as the
  reduction operator, and the same `zero` in the algebra. The result of this
  stage is a single top-level `U` that emerges at the root of the hierarchy at
  the `SERVER`. Actual implementations may structure this step as cascade of
  multiple layers.

* Finally, the `U`-typed result of the reduction performed in the preceding
  stage is projected into the result value using `report` as the mapping
  function (for example, if the structures being merged consist of counters,
  this final step might include computing their ratios).

#### Args:

* <b>`value`</b>: A value of a TFF federated type placed at `CLIENTS` to aggregate.
* <b>`zero`</b>: The zero in the algebra of reduction operators, as described above.
* <b>`accumulate`</b>: The reduction operator to use in the first stage of the process.
    If `value` is of type `{T}@CLIENTS`, and `zero` is of type `U`, this
    operator should be of type `(<U,T> -> U)`.
* <b>`merge`</b>: The reduction operator to employ in the second stage of the process.
    Must be of type `(<U,U> -> U)`, where `U` is as defined above.
* <b>`report`</b>: The projection operator to use at the final stage of the process to
    compute the final resulrt of aggregation. If the indended result to be
    returned by `federated_aggregate` is of type `R@SERVER`, this operator
    must be of type `(U -> R)`.


#### Returns:

A representation on the `SERVER` of the result of aggregating `value` using
the multi-stage process described above.


#### Raises:

* <b>`TypeError`</b>: if the arguments are not of the types specified above.